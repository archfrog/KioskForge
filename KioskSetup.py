#!/usr/bin/env python3
# KioskForge - https://kioskforge.org
# Copyright (c) 2024-2025 Vendsyssel Historiske Museum (me@vhm.dk). All Rights Reserved.
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following
# conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice, this list of conditions and the disclaimer below.
#     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided with the distribution.
#     * Neither the name of Vendsyssel Historiske Museum nor the names of its contributors may be used to endorse or promote
#       products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
# BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
# SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# This script is responsible for setting up the kiosk machine according to the user's kiosk configuration.

# Import Python v3.x's type hints as these are used extensively in order to allow MyPy to perform static checks on the code.
from typing import List

import os
import platform
import stat
import sys
import time

from kiosk.actions import *
from kiosk.builder import TextBuilder
from kiosk.driver import KioskDriver
from kiosk.errors import *
from kiosk.internet import internet_active
from kiosk.invoke import invoke_text, Result
from kiosk.logger import Logger
from kiosk.setup import Setup
from kiosk.script import Script
from kiosk.version import *


class KioskSetup(KioskDriver):
	"""This class contains the 'KioskSetup' code, which configures a supported Ubuntu Server system to become a web kiosk."""

	def __init__(self) -> None:
		KioskDriver.__init__(self)
		self.version = Version("KioskSetup", VERSION, COMPANY, CONTACT, TESTING)

	def _main(self, logger : Logger, origin : str, arguments : List[str]) -> None:
		# Output program banner and an empty line.
		logger.write(self.version.banner())
		logger.write()

		# Check that we're running on Linux.
		if platform.system() != "Linux":
			raise KioskError("This script is can only be run on a Linux kiosk machine")

		# Check that we've got root privileges (instruct MyPy to ignore the Windows-only error in the next line).
		if os.name == "posix" and os.geteuid() != 0:		# type: ignore
			raise KioskError("You must be root (use 'sudo') to run this script")

		# Check that we have got an active, usable internet connection.
		index = 0
		while not internet_active() and index < 6:
			logger.write("*** NETWORK DOWN: Waiting 5 seconds for the kiosk to come online")
			index += 1
			time.sleep(5)
		del index

		if not internet_active():
			logger.error("*" * 50)
			logger.error("*** FATAL ERROR: NO INTERNET CONNECTION AVAILABLE!")
			logger.error("*** (Please check the wifi name and password - both are case-sensitive.)")
			logger.error("*" * 50)
			raise KioskError("No active network connections detected")

		# Display LAN IP - not everybody has access to the router in charge of assigning a LAN IP via DHCP.
		result = invoke_text("hostname -I")
		if result.status == 0:
			logger.write("*** LAN IP: %s" % result.output)
		else:
			logger.error("*** Error: Could not query LAN IP")

		# Parse command-line arguments.
		if len(arguments) >= 2:
			raise SyntaxError("\"KioskSetup.py\" ?step\nWhere 'step' is an optional resume step from the log.")
		resume = 0
		if len(arguments) == 1:
			resume = int(arguments[0])

		# This script is launched by a systemd service, so we need to eradicate it and all traces of it (once only).
		if resume == 0:
			result = invoke_text("systemctl disable KioskSetup")
			if os.path.isfile("/usr/lib/systemd/system/KioskSetup.service"):
				os.unlink("/usr/lib/systemd/system/KioskSetup.service")
			if result.status != 0:
				raise KioskError("Unable to disable the KioskSetup service")

		# Load settings generated by KioskForge on the desktop machine.
		setup = Setup()
		setup.load(origin + os.sep + "KioskForge.cfg")

		# Build the script to execute.
		logger.write("Starting installation of kiosk system:")
		logger.write()
		logger.write("STEP ACTION")
		script = Script(logger, resume)

		# Set environment variable to stop dpkg from running interactively.
		os.environ["DEBIAN_FRONTEND"] = "noninteractive"

		# Assign hostname (affects logs and journals so we do it as the very first thing).
		script += ExternalAction("Setting host name.", "hostnamectl set-hostname " + setup.hostname.data)

		# Append lines to .bashrc to create 'kiosklog' function used for quickly viewing the Kiosk*.py log entries.
		lines  = TextBuilder()
		lines += ""
		lines += "# Function that displays all syslog entries made by Kiosk*.py."
		lines += "kiosklog() {"
		lines += "\t# Use 'kiosklog -p 3' only see kiosk-related errors, instead of all messages."
		lines += "\tjournalctl -o short-iso $* | grep -F Kiosk"
		lines += "}"
		script += AppendTextAction(
			"Creating 'kiosklog' Bash function for easier debugging, and bug and status reporting.",
			"%s/.bashrc" % os.path.dirname(origin),
			lines.text
		)

		# Set environment variable on every boot to stop dpkg from running interactively.
		lines  = TextBuilder()
		lines += 'DEBIAN_FRONTEND="noninteractive"'
		script += AppendTextAction(
			"Configuring 'apt', 'dpkg', etc. to never interact with the user.",
			"/etc/environment",
			lines.text
		)
		del lines

		# Disable interactive activity from needrestart (otherwise it could get stuck in a TUI dialogue during an upgrade).
		script += ReplaceTextAction(
			"Configuring 'needrestart' to NOT use interactive dialogues during upgrades.",
			"/etc/needrestart/needrestart.conf",
			"$nrconf{restart} = 'i';",
			"$nrconf{restart} = 'a';"
		)

		# Configure 'apt' to never update package indices on its own.  We do this in a cron job below.
		script += ReplaceTextAction(
			"Configuring 'apt' to never update package indices on its own.",
			"/etc/apt/apt.conf.d/10periodic",
			'APT::Periodic::Update-Package-Lists "1";',
			'APT::Periodic::Update-Package-Lists "0";'
		)

		# Create file instructing 'apt' to never replace existing local configuration files during upgrades.
		lines  = TextBuilder()
		lines += '// Instruct dpkg to never replace existing local configuration files during upgrades.'
		lines += '// See https://raphaelhertzog.com/2010/09/21/debian-conffile-configuration-file-managed-by-dpkg/'
		lines += 'Dpkg::Options {'
		lines += '    "--force-confdef";'
		lines += '    "--force-confold";'
		lines += '}'
		script += CreateTextWithUserAndModeAction(
			"Creating 'apt' configuration file to keep existing configuration files during upgrades.",
			"/etc/apt/apt.conf.d/00local",
			"root",
			stat.S_IRUSR | stat.S_IWUSR,
			lines.text
		)
		del lines

		# Ensure NTP is enabled (already active in Ubuntu Server 24.04+).
		script += ExternalAction("Enabling Network Time Protocol (NTP).", "timedatectl set-ntp on")

		if setup.wifi_name.data != "":
			# Disable WIFI power-saving mode, which can cause WIFI instability and slow down the WIFI network a lot.
			# NOTE: I initially did this via a @reboot cron job, but it didn't work as cron was run too early.
			# NOTE: Package 'iw' is needed to disable power-saving mode on a specific network card.
			# NOTE: Package 'net-tools' contains the 'netstat' utility.
			script += InstallPackagesAction("Installing network tools to disable WiFi power-saving mode.", ["iw", "net-tools"])
			lines  = TextBuilder()
			lines += "#!/usr/bin/bash"
			lines += "for netcard in `netstat -i | tail +3 | awk '{ print $1; }' | fgrep w`; do"
			lines += "    /sbin/iw $netcard set power_save off"
			lines += "done"
			script += CreateTextWithUserAndModeAction(
				"Creating script to disable power-saving on WiFi card.",
				"%s/kiosk-disable-wifi-power-saving.sh" % origin,
				setup.user_name.data,
				stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
				stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
				stat.S_IROTH | stat.S_IWOTH | stat.S_IXOTH,
				lines.text
			)
			del lines
			script += ExternalAction("Disabling WiFi power-saving mode.", "%s/kiosk-disable-wifi-power-saving.sh" % origin)

			# Create a systemd service to disable WiFi power saving on every boot.
			lines  = TextBuilder()
			lines += "[Unit]"
			lines += "Wants=network-online.target"
			lines += "After=network-online.target"
			lines += ""
			lines += "[Service]"
			lines += "Type=simple"
			lines += "ExecStart=%s/kiosk-disable-wifi-power-saving.sh" % origin
			script += CreateTextWithUserAndModeAction(
				"Creating systemd unit to disable WiFi power saving on every boot.",
				"/usr/lib/systemd/system/kiosk-disable-wifi-power-saving.service",
				"root",
				stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP | stat.S_IROTH | stat.S_IWOTH,
				lines.text
			)
			del lines

			# Enable the new systemd unit.
			script += ExternalAction(
				"Enabling systemd service to disable WiFi power saving.",
				"systemctl enable kiosk-disable-wifi-power-saving"
			)

		# TODO: Disable IPv6 as it apparently slows down Internet communication and is claimed to make the network stack unstable.
		if False:
			"""
				apt-get install -y net-tools
				TARGET=/etc/rc.local
				echo "#!/usr/bin/bash" >> $TARGET
				# NOTE: 'all' and 'default' do not always include all active network cards; apparently they are set up very early.
				echo "# Disable IPv6 on all active interfaces." >> $TARGET
				for netcard in all default `netstat -i | tail +3 | awk '{ print $1; }'`; do
					if [ -f /proc/sys/net/ipv6/conf/$netcard/disable_ipv6 ]; then
						echo sysctl -wq net.ipv6.conf.$netcard.disable_ipv6=1 >> $TARGET
					fi
				done
				chmod a+x $TARGET
				unset -v TARGET
			"""

		# Install and configure SSH server to require a key and disallow root access.
		#...Install OpenSSH server.
		script += InstallPackagesAction("Installing OpenSSH server.", ["openssh-server"])

		# ...Install SSH public key, if any, so that the user can SSH into the box in case of errors or other issues.
		if setup.ssh_key.data:
			script += AppendTextAction(
				"Installing public SSH key in user's home directory.",
				"%s/.ssh/authorized_keys" % os.path.dirname(origin),
				setup.ssh_key.data + "\n"
			)
			#...Disable root login, if not alreadsy disabled.
			script += ReplaceTextAction(
				"Disabling root login using SSH if not already disabled.",
				"/etc/ssh/sshd_config",
				"#PermitRootLogin prohibit-password",
				"PermitRootLogin no"
			)
			#...Disable password-only authentication if not already disabled.
			script += ReplaceTextAction(
				"Requiring private SSH key to log in.",
				"/etc/ssh/sshd_config",
				"#PasswordAuthentication yes",
				"PasswordAuthentication no"
			)

		#...Disable empty passwords (probably superflous, but it doesn't hurt).
		script += ReplaceTextAction(
			"Disabling empty SSH password login.",
			"/etc/ssh/sshd_config",
			"#PermitEmptyPasswords no",
			"PermitEmptyPasswords no"
		)

		# Uninstall package unattended-upgrades as I couldn't get it to work even after spending many hours on it.
		# NOTE: Remove unattended-upgrades early on as it likes to interfere with APT and the package manager.
		script += PurgePackagesAction("Purging package unattended-upgrades.", ["unattended-upgrades"])
		script += RemoveFolderAction("Removing remains of package unattended-upgrades.", "/var/log/unattended-upgrades")

		# Install US English and user-specified locales (purge all others).
		script += ExternalAction("Configuring system locales.", "locale-gen --purge en_US.UTF-8 %s" % setup.locale.data)

		# Configure system to use user-specified locale (keep messages and error texts in US English).
		script += ExternalAction(
			"Setting system locale.",
			"update-locale LANG=%s LC_MESSAGES=en_US.UTF-8" % setup.locale.data
		)

		# Set timezone to use user's choice.
		script += ExternalAction("Setting timezone.", "timedatectl set-timezone " + setup.timezone.data)

		# Configure and activate firewall, allowing only SSH at port 22.
		script += ExternalAction("Disabling firewall logging.", "ufw logging off")
		script += ExternalAction("Allowing SSH through firewall.", "ufw allow ssh")
		script += ExternalAction("Enabling firewall.", "ufw --force enable")

		# Remove some packages that we don't need in kiosk mode to save some memory.
		script += PurgePackagesAction("Purging unwanted packages.", ["modemmanager", "open-vm-tools", "needrestart"])

		# Update and upgrade the system.
		script += UpdateSystemAction()
		script += UpgradeSystemAction()
		script += UpgradeSnapsAction()

		# If the packages option is specified, install the extra package or packages.
		if setup.user_packages.data != "":
			script += InstallPackagesAction("Install user-specified (custom) packages", shlex.split(setup.user_packages.data))

		# Install audio system (Pipewire) only if explicitly enabled.
		if setup.sound_card.data != "none":
			# NOTE: Uncommenting '#hdmi_drive=2' in 'config.txt' MAY be necessary in some cases, albeit it works without for me.
			# Install Pipewire AND pulseaudio-utils as the script 'KioskLaunchX11.py' uses 'pactl' from the latter package.
			script += InstallPackagesAction("Installing Pipewire audio subsystem.", ["pipewire", "pulseaudio-utils"])

			# Append lines to .bashrc to configure the Pipewire audio subsystem.
			lines  = TextBuilder()
			lines += "#!/usr/bin/env python3"
			lines += ""
			lines += "from kiosk.invoke import invoke_text"
			lines += ''
			lines += '# Set default output device to %s.' % setup.sound_card.data
			# NOTE: 'wpctl' only accepts ids so we cheat and ask PulseAudio's pactl to do the job for us.
			CARDS = {
				'pi4b.jack'  : 'alsa_output.platform-bcm2835_audio.stereo-fallback',
				'pi4b.hdmi1' : 'alsa_output.platform-fef00700.hdmi.hdmi-stereo',
				'pi4b.hdmi2' : 'alsa_output.platform-fef05700.hdmi.hdmi-stereo'
			}
			lines += "# For some bizarre reason, 'pactl' returns 1 on success (no error message is displayed): Ignore the result."
			lines += 'invoke_text("pactl set-default-sink %s")' % CARDS[setup.device.data + "." + setup.sound_card.data]
			del CARDS
			lines += ''
			lines += '# Set the audio level to user-specified percentage on a logarithmic scale.'
			lines += 'invoke_text("wpctl set-volume @DEFAULT_AUDIO_SINK@ %.2f")' % (setup.sound_level.data / 100.0)
			lines += ''
			script += CreateTextWithUserAndModeAction(
				"Creating KioskSound.py Pipewire configuration script.",
				"%s/KioskSound.py" % origin,
				setup.user_name.data,
				stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR,
				lines.text
			)
			del lines

			lines  = TextBuilder()
			lines += ""
			lines += "# Configure Pipewire default device and volume."
			lines += "%s/KioskSound.py" % origin
			script += AppendTextAction(
				"Starting KioskSound.py script configure the Pipewire audio subsystem at every login.",
				"%s/.bashrc" % os.path.dirname(origin),
				lines.text
			)

		# Configure the kiosk according to its type.
		if setup.type.data in [ "x11", "web" ]:
			# Create X11 configuration file to rotate the TOUCH panel.  This does not affect the display itself (see KioskStart.py).
			if setup.orientation.data != 0:
				# NOTE: The matrices have been verified against https://wiki.ubuntu.com/X/InputCoordinateTransformation.
				matrices = {
					0 : '1 0 0 0 1 0 0 0 1',
					1 : '0 -1 1 1 0 0 0 0 1',
					2 : '-1 0 1 0 -1 1 0 0 1',
					3 : '0 1 0 -1 0 1 0 0 1'
				}

				# Write '/etc/X11/xorg.conf.d/99-kiosk-set-touch-orientation.conf' to make X11 rotate the touch panel itself.
				# Source: https://gist.github.com/autofyrsto/6daa5d41c7f742dd16c46c903ba15c8f
				lines  = TextBuilder()
				lines += 'Section "InputClass"'
				lines += '\tIdentifier "Coordinate Transformation Matrix"'
				lines += '\tMatchIsTouchscreen "on"'
				lines += '\tMatchDevicePath "/dev/input/event*"'
				lines += '\tMatchDriver "libinput"'
				lines += '\tOption "CalibrationMatrix" "%s"' % matrices[setup.orientation.data]
				lines += 'EndSection'
				script += CreateTextWithUserAndModeAction(
					"Creating X11 configuration file to rotate the touch panel.",
					"/etc/X11/xorg.conf.d/99-kiosk-set-touch-orientation.conf",
					"root",
					stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH,
					lines.text
				)
				del lines
				del matrices

			# Install X Windows server and the OpenBox window manager.
			script += InstallPackagesNoRecommendsAction(
				"Installing X Windows and OpenBox window manager.",
				# NOTE: First element used to be 'xserver-xorg', then '"xserver-xorg-core', and no 'xorg'.
				# NOTE: Changed because of unmet dependencies; i.e. apt suddenly wouldn't install it anymore.
				["xserver-xorg", "x11-xserver-utils", "xinit", "openbox", "xdg-utils"]
			)

			# Create '~/KioskForge/KioskLaunchX11.py' script for starting X/Windows and OpenBox.
			# TODO: Incorporate https://www.reddit.com/r/pipewire/comments/13w2xyk/comment/jmj138k/ (use 'wpctl' even if it is sad).
			lines  = TextBuilder()
			lines += '#!/usr/bin/env python3'
			lines += ''
			lines += 'import os'
			lines += 'import sys'
			lines += 'import time'
			lines += ''
			lines += 'from kiosk.errors import KioskError'
			lines += 'from kiosk.invoke import invoke_text_safe'
			lines += ''
			lines += '# Abort the script if $DISPLAY is defined or $XDG_VTNR is not equal to 1.'
			lines += 'if os.environ.get("DISPLAY") or os.environ.get("XDG_VTNR") != "1":'
			lines += '\tsys.exit(1)'
			lines += ''
			lines += '# Handle KioskError exception that MAY be thrown by "invoke_text_safe()"'
			lines += 'try:'
			lines += '\t# Launch the X server, which launches `.config/openbox/autostart` to eventually launch Chromium in kiosk mode.'
			lines += '\tinvoke_text_safe("startx%s")' % (" -- -nocursor" if not setup.mouse.data else "")
			lines += 'except KioskError as that:'
			lines += '\tprint("Error: %s" % that.text)'
			lines += '\tsys.exit(1)'
			lines += ''
			lines += '# Signal success to the caller.'
			lines += 'sys.exit(0)'
			script += CreateTextWithUserAndModeAction(
				"Creating Bash startup script.",
				"%s/KioskLaunchX11.py" % origin,
				setup.user_name.data,
				stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR,
				lines.text
			)
			del lines

			# Append lines to .bashrc to run the custom startup script at automatic login.
			lines  = TextBuilder()
			lines += ""
			lines += "# Launch X11 and OpenBox into Kiosk mode."
			lines += "%s/KioskLaunchX11.py" % origin
			script += AppendTextAction(
				"Starting X11 startup script at automatic login.",
				"%s/.bashrc" % os.path.dirname(origin),
				lines.text
			)
			del lines

			if setup.type.data == "web":
				# Install Chromium as we use its kiosk mode (also installs CUPS, see below).
				script += ExternalAction("Installing Chromium web browser.", "snap install chromium")

				# ...Stop and disable the Common Unix Printing Server (cups) as we definitely won't be needing it on a kiosk machine.
				script += ExternalAction(
					"Purging Common Unix Printing System (cups) installed automatically with Chromium.",
					"snap remove --purge cups"
				)

				# Write almost empty Chromium preferences file to disable translate.
				lines = TextBuilder()
				lines += '{"translate":{"enabled":false}}'
				script += CreateTextWithUserAndModeAction(
					"Disabling Translate feature in Chromium web browser.",
					"%s/snap/chromium/common/chromium/Default/Preferences" % os.path.dirname(origin),
					setup.user_name.data,
					stat.S_IRUSR | stat.S_IWUSR,
					lines.text
				)
				del lines

				# Install 'xprintidle' used to detect X idle periods and restart the browser (required even if idle_timeout == 0).
				script += InstallPackagesNoRecommendsAction(
					"Installing 'xprintidle' used to restart browser whenever idle timeout expires.",
					["xprintidle"]
				)

				# Create fresh OpenBox autostart script (overwrite the existing autostart script, if any).
				# NOTE: OpenBox does not seem to honor the shebang (#!) as OpenBox always uses the 'dash' shell.
				# NOTE: For this reason, we create a separate Python script, which is launched from OpenBox's autostart file.
				lines  = TextBuilder()
				lines += "#!/usr/bin/dash"
				lines += "%s/KioskStart.py" % origin
				script += CreateTextWithUserAndModeAction(
					"Creating OpenBox startup script.",
					"%s/.config/openbox/autostart" % os.path.dirname(origin),
					setup.user_name.data,
					stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR,
					lines.text
				)
				del lines
			elif setup.type.data == "x11":
				raise InternalError("Untested code")

				# Append lines to .bashrc to run the custom startup script at automatic login.
				lines  = TextBuilder()
				lines += ""
				lines += "# Launch the custom command upon starting X11."
				lines += "%s/KioskLaunchX11.py" % origin
				script += AppendTextAction(
					"Starting X11 startup script at automatic login.",
					"%s/.bashrc" % os.path.dirname(origin),
					lines.text
				)
				del lines

				# Create fresh OpenBox autostart script (overwrite the existing autostart script, if any).
				# NOTE: OpenBox does not seem to honor the shebang (#!) as OpenBox always uses the 'dash' shell.
				# NOTE: For this reason, we create a separate Python script, which is launched from OpenBox's autostart file.
				lines  = TextBuilder()
				lines += "#!/usr/bin/dash"
				lines += "%s/KioskStart.py" % origin
				script += CreateTextWithUserAndModeAction(
					"Creating OpenBox startup script.",
					"%s/.config/openbox/autostart" % os.path.dirname(origin),
					setup.user_name.data,
					stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR,
					lines.text
				)
				del lines
		elif setup.type.data == "cli":
			# Append custom command to .bashrc.
			lines  = TextBuilder()
			lines += ""
			lines += "# Execute the custom command provided to KioskForge."
			lines += setup.user_command.data
			script += AppendTextAction(
				"Appending custom command to .bashrc",
				"%s/.bashrc" % os.path.dirname(origin),
				lines.text
			)
			del lines
		else:
			raise KioskError("Unknown kiosk type: %s" % setup.type.data)

		# Set up automatic login for the named user.
		lines  = TextBuilder()
		lines += "[Service]"
		lines += "ExecStart="
		lines += "ExecStart=-/sbin/agetty --noissue --autologin %s %%I $TERM" % setup.user_name.data
		lines += "Type=simple"
		script += CreateTextWithUserAndModeAction(
			"Creating systemd auto-login script.",
			"/etc/systemd/system/getty@tty1.service.d/override.conf",
			"root",
			stat.S_IRUSR | stat.S_IWUSR,
			lines.text
		)
		del lines

		# Instruct snap to only upgrade at the user-specified interval.
		script += ExternalAction(
			"Instruct 'snap' to update every day at configured time.",
			"snap set system refresh.timer=%s" % setup.snap_time.data,
		)

		# Create cron job to vacuum/compact the system logs every N days.
		if setup.vacuum_time.data != "":
			lines  = TextBuilder()
			lines += "# Cron job to vacuum (compact) the server logs every day so as to avoid the disk becoming full after years of use."
			lines += "%s %s * * *\troot\tjournalctl --vacuum-time=%dd" % (
				setup.vacuum_time.data[3:5], setup.vacuum_time.data[0:2], setup.vacuum_days.data
			)
			lines += ""
			script += CreateTextAction(
				"Creating cron job to vacuum/compact system at configured interval.",
				"/etc/cron.d/kiosk-vacuum-logs",
				lines.text
			)
			del lines

		# Create cron job to update, upgrade, clean, and reboot the system every day at a given time.
		if setup.upgrade_time.data != "":
			lines  = TextBuilder()
			lines += "# Cron job to upgrade, clean, and reboot the system every day at %s." % setup.upgrade_time.data
			lines += '%s %s * * *\troot\tapt-get update; apt-get upgrade -y > %s/apt-upgrade.log; apt-get clean; reboot' % (
				setup.upgrade_time.data[3:5], setup.upgrade_time.data[0:2], origin
			)
			lines += ""
			script += CreateTextAction(
				"Creating cron job to upgrade system every day.",
				"/etc/cron.d/kiosk-upgrade-system",
				lines.text
			)
			del lines

		# Create cron job to power off the system at a given time (only usable when it is manually turned on again).
		if setup.poweroff_time.data != "":
			lines  = TextBuilder()
			lines += "# Cron job to shut down the kiosk machine nicely every day at %s." % setup.poweroff_time.data
			lines += "%s %s * * *\troot\tpoweroff" % (setup.poweroff_time.data[3:5], setup.poweroff_time.data[0:2])
			script += CreateTextAction(
				"Creating cron job to power off the system every day at the configured time.",
				"/etc/cron.d/kiosk-power-off",
				lines.text
			)
			del lines

		# Create swap file in case the system gets low on memory.
		if setup.swap_size.data > 0:
			script += ExternalAction(
				"Allocating swap file.",
				"fallocate -l %dG /swapfile" % setup.swap_size.data,
			)
			script += ExternalAction(
				"Setting permissions on new swap file.",
				"chmod 600 /swapfile"
			)
			script += ExternalAction(
				"Formatting swap file.",
				"mkswap /swapfile"
			)
			script += AppendTextAction(
				"Creating '/etc/fstab' entry for the new swap file.",
				"/etc/fstab",
				"/swapfile\tnone\tswap\tsw\t0\t0"
			)

		# Change ownership of all files in the user's home dir to that of the user as we create a few files as sudo (root).
		script += ExternalAction(
			"Setting ownership of all files in user's home directory to that user.",
			"chown -R %s:%s %s" % (setup.user_name.data, setup.user_name.data, os.path.dirname(origin))
		)

		# Free disk space by purging unused packages.
		script += PurgePackagesAction("Purge all unused packages to free disk space.", [])

		# Free disk space by cleaning the apt cache.
		script += CleanPackageCacheAction()

		# Synchronize all changes to disk (may take a while on microSD cards).
		script += ExternalAction(
			"Flushing disk buffers before rebooting (may take a while on microSD cards).",
			"sync"
		)

		# Execute the script.
		result = script.execute()
		if result.status != 0:
			raise KioskError(result.output)

		# NOTE: The reboot takes place immediately, control probably never returns from the 'execute()' method below!
		logger.write("**** SUCCESS - REBOOTING SYSTEM INTO KIOSK MODE")
		RebootSystemAction().execute()


if __name__ == "__main__":
	app = KioskSetup()
	code = app.main(sys.argv)
	sys.exit(code)

